#+TITLE: Emacs configuration
* Your customizations
  You will need to tell Emacs a little about your particular setup:

  First, let Emacs know where it is you keep your =.bib= file:


  #+BEGIN_SRC emacs-lisp
    (defvar my/bib-file-location "h:/project/uncertainty/uncertainty.bib"
      "Where I keep my bib file.")
  #+END_SRC
* Emacs package management
  This section sets up emacs' package management system. MELPA and ELPA are the two biggest repos for packages. Windows is a pain because it doesn't work well with =https= so we have to fallback to =http=. The second thing we do here is to make sure that [[https://github.com/jwiegley/use-package][use-package]] is installed:

  #+BEGIN_SRC emacs-lisp
    (require 'package)
    (setq package-enable-at-startup nil)

    ;; Windows has issues using https:// instead of http:// so we want to
    ;; set the package locations to use the secure connection when they
    ;; can:
    (cond
     ((string-equal system-type "windows-nt") ; Microsoft Windows
      (progn
        (setq package-archives
              '(("melpa" . "http://melpa.org/packages/")
                ("elpa" . "http://elpa.gnu.org/packages/")))))
     ((or (string-equal system-type "gnu/linux") (string-equal system-type "darwin")) ; Linux & Mac OS X
      (progn
        (setq package-archives
              '(("melpa" . "https://melpa.org/packages/")
                ("elpa" . "https://elpa.gnu.org/packages/"))))))

    (package-initialize)

    ;; We'll use the use-package package to mange our config. Make sure
    ;; it's installed:
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package))

    ;; Make use-package available for use:
    (eval-when-compile
      (require 'use-package))
    (require 'bind-key)

  #+END_SRC
* Dealing with default emacs
  Emacs was created probably before you were born, which makes it super ancient in computer terms. In this section, we override some of the (now) silly default behavior so that emacs acts more like we expect a program to act in the 21st century. We'll load up some better default settings, activate auto-completion, and enable a smart way of dealing with pairs (e.g. parentheses, quotes, etc)

  In particular, we load =better-defaults=, a package that selects some better default settings for Emacs. it you're interested what it does, you can look at it [[https://github.com/technomancy/better-defaults][on github]]:

  #+BEGIN_SRC emacs-lisp
    (delete-selection-mode) ; if I select something then type, delete it and replace it
    (use-package better-defaults
      :ensure t)
    (menu-bar-mode) ; better-defaults disables this but it's useful when you're getting used to Emacs
    (setq scroll-conservatively 1000) ; when point moves offscreen, don't jump to recenter it
    (setq visible-bell nil) ; fix for bug in Mac, see http://stuff-things.net/2015/10/05/emacs-visible-bell-work-around-on-os-x-el-capitan/
    (setq ring-bell-function 'ignore)
  #+END_SRC

  In my world, =C-z= is undo, not minimize emacs:

  #+BEGIN_SRC emacs-lisp
    ;; comment this part since I use Evil
    ;; (global-set-key (kbd "C-z") #'undo)
  #+END_SRC

  We also want words to wrap around nicely. The default behavior wraps in the middle of a word, which is awful:

  #+BEGIN_SRC emacs-lisp
    (global-visual-line-mode)
  #+END_SRC

  The default font size(10pt) is too small for me personally, so I want to rescale it a little bit.

  #+BEGIN_SRC emacs-lisp
    (set-face-attribute 'default nil :height 140)
  #+END_SRC



** Fix for Mac
   Emacs on Mac sometimes can't find installed programs (e.g. R, spellcheck). This fixes that:

   #+BEGIN_SRC emacs-lisp
     (when (memq window-system '(mac ns))
       (use-package exec-path-from-shell
         :ensure t
         :config
         (exec-path-from-shell-initialize)))
   #+END_SRC
** Auto completion 
   We'll use =company= (short for "complete anything") to do auto-completion. This will, for example, enable the same kind of pop-up messages that mimic [[https://support.rstudio.com/hc/en-us/articles/205273297-Code-Completion][Rstudio's autocomplete features]]. As of this writing (August 2016), Emacs' autocompletion isn't quite as good as Rstudios. In particular, it won't pick up on variables from =data.frames= that you've passed to e.g. =dplyr= functions through piping calls. (e.g. ~mtcars %>% filter()~) won't give you =mpg= as an option inside the filter statement. Having said that, =company= does a really good job:

   #+BEGIN_SRC emacs-lisp
     (use-package company
       :ensure t
       :config
       (add-hook 'after-init-hook #'global-company-mode)
       :config
       (define-key company-active-map (kbd "<tab>")
         (lambda () (interactive) (company-complete-common-or-cycle 1)))
       (use-package company-quickhelp
         :ensure t
         :config
         (company-quickhelp-mode 1))
         (setq company-quickhelp-delay nil))  ;;set to nil to avoid automatically pop up help html
   #+END_SRC

** Smartparens
   This package will help you deal with matching pairs (e.g. (), "", etc) by automatically inserting the closing pair when you open it and allowing you to "wrap" expressions that are selected (in other words, if you've already written something and you realize you want it in quotes/parens, just highlight it and press the " or ( ):

   #+BEGIN_SRC emacs-lisp
     (use-package smartparens
       :ensure t
       :init
       (require 'smartparens-config)
       (smartparens-global-mode)
       (show-smartparens-global-mode))
   #+END_SRC

** Backup files
   I want emacs to make these, but don't want to clutter up my project folders with tons of backup files. Solution: put them in the ~.emacs.d/~ directory.
   #+BEGIN_SRC emacs-lisp
     (setq backup-directory-alist
           `(("." . ,(expand-file-name
                      (concat user-emacs-directory "backups")))))
   #+END_SRC
   
** Spell check 
   We can use =flyspell= for on-the-fly spell checking, similar to what we get with MS Word or whatever. =C-;= runs =flyspell-auto-correct-previous-word= which automatically corrects the last word still on screen. If it doesn't guess right the first time, press it again. 
   #+BEGIN_SRC emacs-lisp
     (use-package flyspell
       :ensure t
       :init
       ;;While it always spells a flyspell enabling error message, 
       ;;which is a kind of anonying.
       (setq flyspell-issue-welcome-flag nil)) ;; fix flyspell problem
       :config
       (add-hook 'text-mode-hook #'turn-on-flyspell)
       (add-hook 'prog-mode-hook #'flyspell-prog-mode)
       (add-hook 'ess-mode-hook #'flyspell-prog-mode)
   #+END_SRC

* R (ESS)
  ESS (short for Emacs Speaks Statistics) is the package that lets Emacs know about R and how it works. Let's load it up. No need to make sure that it is installed like we did with =use-package= in the previous section - =use-package= lets us just say "ensure" and will install it if it doesn't exist:  

  #+BEGIN_SRC emacs-lisp
    (use-package ess-site
      :ensure ess)
  #+END_SRC

* Evil
  Evil is an extensible vi layer for Emacs. It emulates the main features of Vim, and provides facilities for writing custom extensions.

  #+BEGIN_SRC emacs-lisp
    (use-package evil
      :ensure t
      :init
      (evil-mode 1) ;;enable evil mode by default
      (setq evil-default-state 'emacs) ;; enter emacs mode after initialize
      (define-key evil-emacs-state-map (kbd "C-o") 'evil-execute-in-normal-state) ;;temporary enter evil mode
      :config
      ;; show which mode is in
      (setq evil-normal-state-tag "NORMAL")
      (setq evil-insert-state-tag "INSERT")
      (setq evil-visual-state-tag "VISUAL")
      )
  #+END_SRC

* Latex (AuCTeX)
  If you use latex to do any writing, you'll be happy to know that emacs is the highest-rated latex editor [[http://tex.stackexchange.com/questions/339/latex-editors-ides/][on stackexchange]].
  
  #+BEGIN_SRC emacs-lisp
    (use-package tex-site
      :ensure auctex
      :mode ("\\.tex\\'" . latex-mode)
      :config
      (setq TeX-parse-self t)
      ;; Here we make auctex aware of latexmk and xelatexmk. We can use
      ;; these instead of calling pdflatex, bibtex, pdflatex, pdflatex (or
      ;; similar). I'll set latexmk as the default as there's really no
      ;; reason to use pdflatex
      (eval-after-load "tex"
        '(add-to-list 'TeX-command-list '("latexmk" "latexmk -synctex=1 -shell-escape -pdf %s" TeX-run-TeX nil t :help "Process file with latexmk")))
      (eval-after-load "tex"
        '(add-to-list 'TeX-command-list '("xelatexmk" "latexmk -synctex=1 -shell-escape -xelatex %s" TeX-run-TeX nil t :help "Process file with xelatexmk")))
      (add-hook 'TeX-mode-hook '(lambda () (setq TeX-command-default "latexmk"))))
  #+END_SRC

* Markdown
  Markdown is a good way to write up most things, though it doesn't hold a candle to emacs's built-in org-mode:

  #+BEGIN_SRC emacs-lisp
    (use-package markdown-mode
      :ensure t)
  #+END_SRC

* Flycheck 
  Modern on-the-fly syntax checking extension for GNU Emacs.

  #+BEGIN_SRC emacs-lisp
    (use-package flycheck
      :ensure t
      :init (global-flycheck-mode))
  #+END_SRC

Then press C-M-x with point somewhere in this form to install and enable Flycheck for the current Emacs session.

* Rmarkdown/knitr (polymode)
  Polymode is a package that lets us use emacs to edit rmarkdown and sweave-type files that combine markdown or latex with R code. Let's load it up and make it aware of the file extensions:

  #+BEGIN_SRC emacs-lisp
    (use-package polymode
      :ensure t
      :mode
      ("\\.Snw" . poly-noweb+r-mode)
      ("\\.Rnw" . poly-noweb+r-mode)
      ("\\.Rmd" . poly-markdown+r-mode))
  #+END_SRC

* Git (magit)
  Magit is an Emacs package that makes dealing with git awesome.

  #+BEGIN_SRC emacs-lisp
    (use-package magit
      :ensure t
      :bind ("C-x g" . magit-status))
  #+END_SRC

* Window-numbering
  Numbered window shortcuts for Emacs.

  #+BEGIN_SRC emacs-lisp
    (use-package window-numbering
      :ensure t
      :init
      (progn
        (window-numbering-mode t)))
  #+END_SRC

* Ivy
  Ivy is a completion framework that helps you find things (files, emacs commands, etc). We set it up here with a super minimal configuration because the reference 

  #+BEGIN_SRC emacs-lisp
    (use-package ivy
      :ensure t
      :config
      (ivy-mode 1))
  #+END_SRC

* Avy
  avy is a GNU Emacs package for jumping to visible text using a char-based decision tree. 
  #+BEGIN_SRC emacs-lisp
    (use-package avy
    :ensure t
    :bind ("M-s" . avy-goto-char))
  #+END_SRC

* Projectile 
  Projectile is a project interaction library for Emacs. Its goal is to provide a nice set of features operating on a project level without introducing external dependencies(when feasible). For instance - finding project files has a portable implementation written in pure Emacs Lisp without the use of GNU find (but for performance sake an indexing mechanism backed by external commands exists as well).
  #+BEGIN_SRC emacs-lisp
    (use-package projectile
      :ensure t
      :bind ("C-x p" . projectile-switch-project)
      :config
      (projectile-global-mode)
      (setq projectile-enable-caching t))
  #+END_SRC

* Expand-region 
  Expand region increases the selected region by semantic units. Just keep pressing the key until it selects what you want.
  #+BEGIN_SRC emacs-lisp
    (use-package expand-region
      :ensure t
      :bind ("C-=" . er/expand-region))
  #+END_SRC

* Smex 
  Smex is a M-x enhancement for Emacs. Built on top of Ido, it provides a convenient interface to your recently and most frequently used commands. And to all the other commands, too.
  #+BEGIN_SRC emacs-lisp
   (use-package smex
     :ensure t
     :defer t
     :bind (("M-x" . smex)
            ("M-X" . smex-major-mode-commands))
     :config
     (progn
      (smex-initialize))) 
  #+END_SRC

* YASnippet 
  YASnippet is a template system for Emacs. It allows you to type an abbreviation and automatically expand it into function templates. Bundled language templates include: C, C++, C#, Perl, Python, Ruby, SQL, LaTeX, HTML, CSS and more. The snippet syntax is inspired from TextMate's syntax, you can even import most TextMate templates to YASnippet. 
  #+BEGIN_SRC emacs-lisp
    (use-package yasnippet
	  :ensure t
      :commands (yas-minor-mode) ; autoload `yasnippet' when `yas-minor-mode' is called
                                            ; using any means: via a hook or by user
                                            ; Feel free to add more commands to this
                                            ; list to suit your needs.
      :init ; stuff to do before requiring the package
      (progn
        (add-hook 'prog-mode-hook #'yas-minor-mode))
      :config ; stuff to do after requiring the package
      (progn
        (yas-reload-all)))
  #+END_SRC

* References & bibliographies 
  This package configuration lets you type =C-c C-r=  to bring up a list of your references. You can then search through it til you find the one you want. Hitting =RET= inserts a citation. There are a few other things you can do besides inserting citations - have a look by highlighting a bib entry and pressing =M-o=. 

=ivy-bibtex= can also keep track of pdfs of articles and notes that you take pertaining to these articles. Since this is a "minimal" configuration, I don't set that up here. If you're interested, look at =bibtex-completion-library-path= and =bibtex-completion-notes-path=

  #+BEGIN_SRC emacs-lisp
    (use-package ivy-bibtex
      :ensure t
      :config 
      (setq bibtex-completion-bibliography my/bib-file-location)
      (bind-key* "C-c C-r" #'ivy-bibtex)
      ;; default is to open pdf - change that to insert citation
      (setq ivy-bibtex-default-action #'ivy-bibtex-insert-citation)
      )
  #+END_SRC

